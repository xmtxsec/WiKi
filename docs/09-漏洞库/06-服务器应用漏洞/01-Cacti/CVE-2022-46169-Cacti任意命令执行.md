
# 0X00 漏洞信息
Cacti是一套基于PHP,MySQL,SNMP及RRDTool开发的网络流量监测图形分析工具，可为用户提供强大且可扩展的操作监控和故障管理框架。<br />该漏洞存在于`remote_agent.php`文件中，攻击者无需身份验证即可访问此文件。攻击者可利用`get_nfilter_request_var()`函数检索的参数`$poller_id`，来满足`poller_item =POLLER_ACTION_SCRIPT_PHP`条件，触发`proc_open()`函数，从而导致命令执行。漏洞利用成功后，未经身份验证的攻击者可以在运行 Cacti 的服务器上执行任意代码。


# 0X01 漏洞概述
| 漏洞名称 | Cacti任意命令执行漏洞 |
| --- | --- |
| 漏洞等级 | 高危 |
| CVE编号 | CVE-2022-46169 |
| CNVD编号 | 暂无 |
| CNNVD编号 | 暂无 |
| 其他编号 | 暂无 |
| 披露时间 | 2022-12-05 |
| 分数 | 9.8 |
| CVSS | CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H |
| 披露链接 | [https://nvd.nist.gov/vuln/detail/CVE-2022-46169](https://nvd.nist.gov/vuln/detail/CVE-2022-46169) |


# 0X02 影响范围
Cacti = 1.2.22


# 0X03 代码审计
该漏洞存在于`remote_agent.php`文件中。无需身份验证即可访问此文件。为了验证客户端是否被允许`remote_client_authorized`调用该函数：
```
if (!remote_client_authorized()) {
	print 'FATAL: You are not authorized to use this service';
	exit;
}
```

此函数检索客户端的 IP地址 `viaget_client_addr`并将此 IP地址解析为相应的主机名 `via gethostbyaddr`。此后，验证poller表中是否存在条目，其中主机名对应于解析的主机名。如果找到这样的条目，函数返回true并且客户端被授权：
```
function remote_client_authorized() {
	// ...
	$client_addr = get_client_addr();
	// ...

	$client_name = gethostbyaddr($client_addr);
           // ...
	$pollers = db_fetch_assoc('SELECT * FROM poller', true, $poller_db_cnn_id);

	if (cacti_sizeof($pollers)) {
		foreach($pollers as $poller) {
			if (remote_agent_strip_domain($poller['hostname']) == $client_name) {
				return true;
			} elseif ($poller['hostname'] == $client_addr) {
				return true;
			}
		}
	}

	cacti_log("Unauthorized remote agent access attempt from $client_name ($client_addr)");

	return false;
}
```

由于功能的实现，可以绕过此授权`get_client_addr`。该函数在文件中定义`lib/functions.php`并检查服务`$_SERVER`变量以确定客户端的 IP 地址：
```
function get_client_addr($client_addr = false) {
	$http_addr_headers = array(
		'X-Forwarded-For',
		'X-Client-IP',
		'X-Real-IP',
		'X-ProxyUser-Ip',
		'CF-Connecting-IP',
		'True-Client-IP',
		'HTTP_X_FORWARDED',
		'HTTP_X_FORWARDED_FOR',
		'HTTP_X_CLUSTER_CLIENT_IP',
		'HTTP_FORWARDED_FOR',
		'HTTP_FORWARDED',
		'HTTP_CLIENT_IP',
		'REMOTE_ADDR',
	);

	$client_addr = false;
	foreach ($http_addr_headers as $header) {
		if (!empty($_SERVER[$header])) {
			$header_ips = explode(',', $_SERVER[$header]);
			foreach ($header_ips as $header_ip) {
				if (!empty($header_ip)) {
					if (!filter_var($header_ip, FILTER_VALIDATE_IP)) {
						cacti_log('ERROR: Invalid remote client IP Address found in header (' . $header . ').', false, 'AUTH', POLLER_VERBOSITY_DEBUG);
					} else {
						$client_addr = $header_ip;
						cacti_log('DEBUG: Using remote client IP Address found in header (' . $header . '): ' . $client_addr . ' (' . $_SERVER[$header] . ')', false, 'AUTH', POLLER_VERBOSITY_DEBUG);
						break 2;
					}
				}
			}
		}
	}

	return $client_addr;
}
```

开头的变量`HTTP_`可以由攻击者任意设置。由于poller表中有一个默认条目，其中包含运行 Cacti 的服务器的主机名，攻击者可以绕过身份验证，例如通过提供标头`Forwarded-For: <TARGETIP>`。这样函数`get_client_addr`返回运行 Cacti 的服务器的 IP 地址。以下调用gethostbyaddr会将此 IP 地址解析为服务器的poller主机名，由于默认条目，该主机名将通过主机名检查。

绕过文件授权后`remote_agent.php`，攻击者可以触发不同的动作。其中一项行动称为polldata：
```
switch (get_request_var('action')) {
	case 'polldata':
		// ...
		poll_for_data();
		// ...
		break;
```

被调用的函数`poll_for_data`检索一些请求参数并从数据库中加载相应的`poller_item`条目。如果`actionapoller_item`等于`POLLER_ACTION_SCRIPT_PHP`，则该函数`proc_open`用于执行 PHP 脚本：
```
function poll_for_data() {
	global $config;

	$local_data_ids = get_nfilter_request_var('local_data_ids');
	$host_id        = get_filter_request_var('host_id');
	$poller_id      = get_nfilter_request_var('poller_id');
	$return         = array();

	$i = 0;

	if (cacti_sizeof($local_data_ids)) {
		foreach($local_data_ids as $local_data_id) {
			input_validate_input_number($local_data_id, 'local_data_id');

			$items = db_fetch_assoc_prepared('SELECT *
				FROM poller_item
				WHERE host_id = ?
				AND local_data_id = ?',
				array($host_id, $local_data_id));
			// ...
			if (cacti_sizeof($items)) {
				foreach($items as $item) {
					switch ($item['action']) {
					// ...
					case POLLER_ACTION_SCRIPT_PHP: /* script (php script server) */
						// ...
						$cactiphp = proc_open(read_config_option('path_php_binary') . ' -q ' . $config['base_path'] . '/script_server.php realtime ' . $poller_id, $cactides, $pipes);
						// ...
```

攻击者控制的参数通过允许任意字符串`$poller_id`的函数检索。`get_nfilter_request_var`此变量稍后插入到传递给的字符串中`proc_open`，这会导致命令注入漏洞。`poller_id=;id`例如，通过提供id命令来执行。

为了到达易受攻击的调用，攻击者必须提供一个`host_id`和`local_data_id`，其中`action`相应`poller_item`的设置为`POLLER_ACTION_SCRIPT_PHP`。这两个 ID（`host_id`和`local_data_id`）都可以很容易地被暴力破解。唯一的要求是存在`poller_item`带有`POLLER_ACTION_SCRIPT_PHP`动作的 a 。这很可能发生在生产实例上，因为此操作是由一些预定义的模板添加的，例如`Device - Uptime`或`Device - Polling Time`。

`poller_item`此命令注入漏洞允许未经身份验证的用户在配置了`action`类型`POLLER_ACTION_SCRIPT_PHP(2) `的情况下执行任意命令。


# 0X04 防护思路
应该通过不允许攻击者使`get_client_addr`(file lib/functions.php) 返回任意 IP 地址来防止授权绕过。这可以通过不遵守`HTTP_... $_SERVER`变量来完成。如果出于兼容性原因应保留这些，至少应防止伪造运行 Cacti 的服务器的 IP 地址。

应通过对文件应用以下更改来防止命令注入`remote_agent.php`：该变量$poller_id应该是一个整数，因此应该通过函数`get_filter_request_var`而不是检索`get_nfilter_request_var`：
```
function poll_for_data() {
	// ...
           $poller_id      = get_filter_request_var('poller_id');
           // ...
```

为了进一步加强对命令注入的防御，`$poller_id`应该`escapeshellarg`在传递给之前进行转义`proc_open`
```
function poll_for_data() {
// ...
$cactiphp = proc_open(read_config_option('path_php_binary') . ' -q ' . $config['base_path'] . '/script_server.php realtime ' . escapeshellarg($poller_id), $cactides, $pipes);
// ...
```


# 0X05 解决方案

1. 官方已发布安全更新，建议升级至最新版本。 
2. 对于在 PHP < 7.0 下运行的 1.2.x 实例，还需要进一步更改， [https://github.com/Cacti/cacti/commit/a8d59e8fa5f0054aa9c6981b1cbe30ef0e2a0ec9](https://github.com/Cacti/cacti/commit/a8d59e8fa5f0054aa9c6981b1cbe30ef0e2a0ec9)
