
# 总结
Upload-labs文件上传系列靶场我们到此已全部更完，下面进行简单总结。<br />![image-20210527151621141.png](_img/assets/1656466500826-473fa764-59ff-4396-8cf1-daef9b522661.png)

![image-20210527151705043.png](_img/assets/1656466505738-6aa2f85d-82d2-4934-8dbc-faea3261e001.png)


## Pass-01(前端验证)
	上传文件的数据包并没有上传到服务端，只是在客户端浏览器使用JavaScript对数据包进行检测。先把文件后缀改为允许上传的后缀，来绕过JS的检测，再抓包，把后缀名改为可执行文件的后缀名即可上传成功。


## Pass-02(MIME验证)
	上传文件时，通过burp进行抓包，将数据包中的Content-Type修改为所上传文件对应的值即可。Content-Type是通过客户端传递的是可以任意修改的。当上传一个php文件时，将Content-Type的值修改为image/jpeg，就可以绕过服务端的检测。


## Pass-03(黑名单验证，特殊后缀)
	服务端代码中限制了某些后缀的文件不能上传，但是有些apache是允许解析其他文件后缀的，在apache的解析顺序中，是从右到左开始解析文件后缀的，如果最右侧的扩展名不可识别，就继续往左判断，直至遇到可以解析的后缀为止所以如果上传文件名类似1.php.xxxx,因为后缀xxxx不能解析，所以向左解析php。


## Pass-04(黑名单验证，.htaccess)
**htaccess文件内容**
```
SetHandler application/x-httpd-php
```

**什么是.htaccess文件**<br />	概述来说，htaccess 文件是 Apache 服务器中的一个配置文件，它负责相关目录下的网页配置。通过 htaccess 文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。由于windows不允许通过文件直接创建.htcaccess文件，可以通过rename来创建。上传.htaccess文件后，可上传任意后缀包含一句话的马。


## Pass-05(黑名单验证，.user.ini)
**.user.ini文件内容**
```
auto_prepend_file=shell.gif
```

**什么是.user.ini文件**<br />`.userini`实际上就是一个可以由用户自定义的php.ini,我们能够自定义的设置是模式为`PHP_INI PERDIR`或者`PHP_INI_USER`的设置。实际上，除了`PHP_INI_SYSTEM`以外的模式(包括`PHP_ INI ALL`)都是可以通过.user.ini来设置的。

**利用.user.ini本地包含文件:**<br />利用条件: `open_ basedir`没有 被限制<br />利函数: `auto_append_file`、 `auto_prepend.file`<br />利用原理:借助`.user.ini`轻松让所有`php`文件都”自动”包含某个文件,而这个文件可以是一个正<br />常`php`文件，也可以是一个包含一 句话的`webshell`<br />`auto_append_file` 表示在加载第一个PHP代码之后执行预加载该配置所指示的PHP文件。


## Pass-06(黑名单验证，大小写绕过)
	没有利用函数`strtolower()`来将后缀改为小写，因此我们可以使用大小写绕过。


## Pass-07(黑名单验证，空格绕过)
	没有利用函数`trim()` 移除字符串两侧的空白字符或其他预定义字符，因此我们可以使用空白符绕过。Windows系统下，对于文件名中空格会被作为空处理，程序中的检测代码却不能自动删除空格。从而绕过黑名单。


## Pass-08(黑名单验证，点号绕过)
	没有利用函数`deldot()`删除字符串末尾的`.`，因此我们可以使用点号绕过。Windows系统下，文件后缀名最后一个点会被自动去除。


## Pass-09(黑名单验证，特殊字符::$DATA绕过)
	没有利用函数`str_ireplace()`函数去除字符串`::$DATA`，因此我们可以使用特殊符号绕过。Windows系统下，如果上传的文件名中test.php::$DATA会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析。


## Pass-10(黑名单验证，代码流程绕过)
	根据代码流程`shell.php. .`首先被trim()函数去空仍然为`shell.php. .`，然后被`deldot()`函数除去末尾的`.`变为`shell.php.<空格>` ，经过`strrchr()`函数提取后缀和`strtolower()`函数转换为小写后仍为`.php.<空格>` ,最后经过`str_ireplace()`函数和`trim()`函数后为`.php.`。
```
shell.php. .  ------->  shell.php. .  --------->  shell.php.<空格>  --------->  .php.<空格>  -------->  .php.
               trim()                 deldeot()                     strrchr()                trim()
```

	在前面Pass-8中我们知道Windows系统下，文件后缀名最后一个点会被自动去除。因此这里我们使用的是点号绕过。


## Pass-11(黑名单验证，双写绕过)
	利用了`str_ireplace()`函数将文件后缀与黑名单进行匹配，匹配成功则将后缀替换为空，从而来限制上传。不过我们可以利用双写绕过，如：`.pphphp`替换后为`.php`。


## Pass-12(白名单验证，0x00截断)
	在将文件随机改名的过程中利用了`$_GET['save_path']`，也就是说文件路径是我们可控的。那么我们可以使用%00来截断进行绕过，%00后的语句是无法识别的。注意：php在5.3.4中修复了%00截断的问题


## Pass-13(白名单验证，0x00截断)
	在将文件随机改名的过程中利用了`$_POST['save_path']`，也就是说文件路径是我们可控的。那么我们可以使用%00来截断进行绕过，%00后的语句是无法识别的，**需要重点注意的是POST不会像GET那样对%00进行自动解码，所以需要在二进制中进行修改**。注意：php在5.3.4中修复了%00截断的问题


## Pass-14(白名单验证，图片马)
	查看源码我们可以看到对上传的文件的二进制前两个字节进行判断，也就是说所上传文件必须为图片文件，在上传页面有提醒我们，使用文件包含漏洞。<br />![image-20210602152656182.png](_img/assets/1656466559769-c3e1e375-377b-4059-9d2e-9ae7e1186516.png)

	制作图片马1.jpg为图片文件，shell.txt为木马源码，shell.jpg为图片马。
```
copy 1.jpg/a+shell.txt/b shell.jpg
```

![image-20210602153947582.png](_img/assets/1656466567777-4953a83c-3b86-4a31-b994-1f42e0b079d6.png)

## Pass-15(白名单验证，图片马)
	与Pass-14中一样利用文件包含和图片马来绕过，但是不同的是这里使用了`getimagesize()` 函数用于获取图像大小及相关信息，也就是说这里的图片马必须是能过打开的一个图片，我们在Pass-14中制作的图片马是一个损坏的图片文件，在这里无法上传成功。

	制作图片马，将一张照片使用notepad打开在末尾加入木马代码，保存后发现仍是一张完好的图片。<br />![image-20210602163428858.png](_img/assets/1656466576076-aff993e7-835a-4149-b6f8-24b2f35be96d.png)


## Pass-16(白名单验证，图片马)
	与Pass-15一样必须上传的是一个完好无损的图片，直接利用Pass-15中的图片马来上传即可。**需要注意的是需要开启**`**php_exif**`**模块**


## Pass-17(白名单验证，图片马+二次渲染)
	对上传的文件进行了二次渲染，也就是说我们上传的图片马木马代码可能被改变，绕过思路为先将图片马上传然后下载经过二次渲染的图片，将图片用十六进制查看软件打开与上传的图片对比，找出未被修改的部分，在该部分写入木马即可。但是这里由于jpg、png、gif的格式不一样，所以并不能像前面一样都通用，不同类型的图片插入位置不同。同一张图片可以在画图中更改为不同的类型。


## Pass-18(白名单验证，条件竞争)
代码流程是先将文件上传，然后再对其文件类型进行判断。那么我们就可以利用在对文件类型进行判断之前的这个间隙来实现目的，这就是条件竞争漏洞。

**何为条件竞争漏洞**<br />	条件竞争漏洞是一种服务器端的漏洞，是由于开发者设计应用程序并发处理时操作逻辑不合理而造成。当应用面临高并发的请求时未能同步好所有请求，导致请求与请求之间产生等待时出现逻辑缺陷。该漏洞一般出现在与数据库系统频繁交互的位置，例如金额同步、支付等较敏感操作处。另外条件竞争漏洞也会出现在其他位置，例如文件的操作处理等。

	假设攻击者上传了一个用来生成恶意shell的文件，在上传完成和安全检查完成并删除它的间隙，攻击者通过不断地发起访问请求的方法访问了该文件，该文件就会被执行，并且在服务器上生成一个恶意shell的文件。至此，该文件的任务就已全部完成，至于后面发现它是一个不安全的文件并把它删除的问题都已经不重要了，因为攻击者已经成功的在服务器中植入了一个shell文件，后续的一切就都不是问题了。


## Pass-19(白名单验证，条件竞争)
	对上传的文件做了很死的限制只能是白名单中类型的文件，不过我们发现代码流程是将文件上传之后再将文件进行更改名称，那么我们就可以利用在对文件名进行更改之前的这个间隙来实现目的，可以将Pass-18中能够生成木马文件的脚本插入图片文件中，然后利用条件竞争来生成shell.php

	apache对文件后缀名的识别是从右向左进行匹配的，以单个.作为分隔符。当遇到未知的文件后缀名时，会继续向左匹配，直到遇到可以识别的后缀名为止。利用apache的这一特性我们可以将文件名命为XXX.php，将文件后缀命名为apache无法解析的后缀如：.7z，合起来也就是XXX.php.7z，当将该文件上传后我们访问该文件，apache无法解析.7z就会将其当作php文件来解析，就可以运行我们插入的恶意代码来生成shell.php。


## Pass-20(黑名单验证，点号绕过)
	使用了`$_POST['save_name']`，也就是说上传后的文件名是我们可控的并且没有其对做任何的限制，虽然使用了在黑名单中进行匹配，不过在Pass-08中我们知道Windows系统下，文件后缀名最后一个点会被自动去除。在这里的点会使`pathinfo()`获取到的`PATHINFO_EXTENSION`为空，所以在这里我们可以使用点号绕过。


## Pass-21(白名单验证，数组绕过)
	通过代码分析我们可以看到最后拼接文件名是将数组的第一个索引和最后一个索引凭借得到的，那么我可以通过控制数组索引值来进行绕过，将索引0为XXX.php，索引2为jpg，即：[XXX.php,jpg]。数组中有两个元素，拼接的是索引0和索引1，也就是1.php和空因为jpg的索引为2不进行拼接索，所以我们最终得到的文件是XXX.php。绕过MIMIE，改一下包的Content-Type即可。
