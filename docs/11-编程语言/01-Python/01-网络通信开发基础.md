
# 一、网络协议

## 1.1、传输控制协议TCP

### 1.1.1、主要特点

1. TCP是面向连接的运输层协议。应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。
2. 每一条TCP连接只能有两个端点(endpoint), 每一条TCP连接只能是点对点的(一对一)。
3. TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。
4. TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。
5. 面向字节流。TCP中的“ 流" (stream)指的是流入到进程或从进程流出的字节序列。“面向字节流”的含义是:虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。


### 1.1.2、TCP报文的首部格式
TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它首部中各字段的作用。TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项(n是整数)。因此TCP首部的最小长度是20字节。
![image.png](_img/assets/1661397915264-8aff1423-0f13-42e1-afd6-2886d16fb0db.png)


### 1.1.3、TCP的链接
每一条TCP连接有两个端点。TCP连接的端点叫做套接字(socket)或插口。根据RFC793的定义:端口号拼接到 IP 地址即构成了套接字。套接字的表示方法是在点分十进制的 IP 地址后面写上端口号，中间用冒号或逗号隔开。TCP连接的端点是个很抽象的套接字，即(IP 地址:端口号)。同一个IP地址可以有多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中。

TCP是面向连接的协议。运输连接是用来传送TCP报文的。TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。因此，运输连接就有三个阶段，即：连接建立、数据传送和连接释放。


### 1.1.4、TCP的链接建立（三次握手）
TCP建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个TCP报文段。
![image.png](_img/assets/1661398067112-a0b94bb3-42e3-44fc-9a1f-2b5fab0be18d.png)

1.  在打算建立TCP连接时，A向B发出连接请求报文段，这时首部中的同步位SYN = 1，同时选择一个初始序号seq = x。TCP规定，SYN报文段(即SYN = 1的报文段)不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT (同步已发送)状态。 
2.  B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号 seq= y。这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入SYN-RCVD ( 同步收到)状态。 
3.  TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1,，确认号ack=y+ 1，而自己的序号seq=x+ 1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq=x+1.这时，TCP 连接已经建立，A进入ESTABLISHED (已建立连接)状态。当B收到A的确认后，也进入ESTABLISHED状态。 


### 1.1.5、TCP连接的释放（四次挥手）
数据传输结束后，通信的双方都可释放连接。现在A和B都处ESTABLISHED状态A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。

![image.png](_img/assets/1661398085639-68c2ef67-ac47-43c8-8b0b-c0ca8e519b72.png)

1.  A把连接释放报文段首部的终止控制位FIN置1,其序号seq = u，它等于前面已传送过的数据的最后一个字节的序号加1。 这时A进入FIN-WAIT-1 (终止等待1)状态，等待B的确认。TCP规定，FIN报文段即使不携带数据，它也消耗掉一个序号。 
2.  B收到连接释放报文段后即发出确认，确认号是ack=u+ 1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT (关闭等待)状态。这时的TCP连接处于半关闭(half-close)状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是从B到A这个方向的连接并未关闭，这个状态可能会持续一段时间。 
3.  A收到来自B的确认后，就进入FIN-WAIT-2 (终止等待2)状态，等待B发出的连接释放报文段。若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN= 1。现假定B的序号为w (在半关闭状态B可能又发送了一些数据)。B还必须重复上次已发送过的确认号ack= u + 1。这时B就进入LAST-ACK ( 最后确认)状态，等待A的确认。 
4.  A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+ 1，而自己的序号是seq=u+ 1 (根据TCP标准，前面发送过的FIN报文段要消耗一个序号)。然后进入到TIME-WAIT (时间等待)状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入到CLOSED状态。 


## 1.2、用户数据报协议UDP

### 1.2.1、主要特点

1. UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。 
2. UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。 
3. UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给UDP多长的报文，UDP就照样发送，一次发送一个报文，在接收方的UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。 
4. UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。 
5. UDP支持一对一、一对多、多对一和多对多的交互通信。 
6. UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。 


### 1.2.2、首部格式
用户数据报UDP有两个字段:**数据字段**和**首部字段**。首部字段很简单，只有8个字节，由四个字段组成，每个字段的长度都是两个字节。

![image.png](_img/assets/1661406271034-3912bcf4-a392-4ca5-9468-b5778ad20e5f.png)

1. 源端口,源端口号。在需要对方回信时选用。不需要时可用全0。
2. 目的端口，目的端口号。这在终点交付报文时必须使用。
3. 长度，UDP用户数据报的长度，其最小值是8 (仅有首部)。
4. 检验和，检测UDP用户数据报在传输中是否有错。有错就丢弃。

当运输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交最后的终点一应用进程。如果接收方UDP发现收到的报文中的目的端口号不正确(即不存在对应于该端口号的应用进程)，就丢弃该报文，并由网际控制报文协议ICMP发送“端口不可达”差错报文给发送方。


## 1.3、Socket
两个程序通过网络进行通信时，二者必须使用Socket（套接字）。Socket用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。


# 二、Python使用Socket通信基本语法
在python中使用socke模块的函数socket就可以实现
```python
test = socket.socket(AddressFamily,Type)

参数
AdressFamily：可以选择AF_INET（用于Internet进程间通信）或者AF_UNIX（用于同一台机器进程间通信），实际工作中常用AF_INET。
Type：套接字类型，可以是SOCK_STREAM（流式套接字，主要用于TCP协议），SOCK_DGRAM（数据报套接字，主要用于UDP协议）。
```

TCPSocket
```python
TCPSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
```

UDPSocket
```python
UDPSocket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
```

Socket对象的内置方法如下表：

| 函数 | 描述 |
| --- | --- |
| s.bind() | 绑定地址（host,port）到套接字 |
| s.listen() | 开始TCP监听 |
| s.accept() | 被动接受TCP客户端连接，并以阻塞的方式等待连接的到来 |
| s.connect() | 主动初始化TCP服务器连接 |
| s.recv() | 接受TCP数据，数据以字符串形式返回 |
| s.send() | 发送TCP数据，将string中的数据发送到连接的套接字 |
| s.sendall() | 完整发送TCP数据 |
| s.recvfrom() | 接受UDP数据 |
| s.sendto() | 发送UDP数据 |
| s.close() | 关闭套接字 |



# 三、代码实现

## 3.1、TCP编程

### 3.1.1、创建TCP服务器
```python
import socket   #导入模块

host = socket.gethostname()  #获取主机地址
port = 6666                  #设置端口

service = socket.socket(socket.AF_INET,socket.SOCK_STREAM)   #创建套接字
service.bind((host,port))        #绑定地址到套接字
service.listen(1)                #设置连接数量
socket,addr = service.accept()   #被动接受TCP客户端连接
print("已建立连接...")

info = socket.recv(1024).decode()  #接受客户端数据

while info != "see you":           #判断是否退出
    if info:
        print("接收到的消息：" + info)
    send_data = input("输入发送的内容：")   #发送消息
    socket.send(send_data.encode())         #发送TCP数据
    if send_data == "see you":
        break
    info = socket.recv(1024).decode()       #接受客户端数据
    
socket.close()          #关闭客户端套接字
service.close()         #关闭服务器套接字
```


### 3.1.2、创建TCP客户端
```python
import socket    #导入模块

host = socket.gethostname()   #获取主机地址
port = 6666                   #设置端口

client = socket.socket()      #创建套接字
client.connect((host,port))   #主动初始化TCP服务器连接
print("已连接...")

info = ""
while info != "see you":    #判断是否退出
    send_data = input("输入发送的内容：")    #输入内容
    client.send(send_data.encode())          #发送TCP数据
    if send_data == "see you":
        break
    info = client.recv(1024).decode()    #接受服务器数据
    print("接收到的内容：" + info)

client.close()      #关闭套接字
```

![image.png](_img/assets/1661416603069-0ee99b55-7bfa-4fcf-bacc-8865ec92269b.png)


## 3.2、UDP编程

### 3.2.1、创建UDP服务器
```python
import socket   #导入模块

host = "127.0.0.1"           #设置主机地址
port = 8080                  #设置端口

service = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)   #创建套接字
service.bind((host,port))        #绑定地址到套接字
print("已建立连接...")

data,addr = service.recvfrom(1024)
data = 3.14 * float(data) * float(data)
send_data = "圆的面积为：" + str(data)
print("消息已反馈")
service.sendto(send_data.encode(),addr)  #发送给客户端
service.close()     #关闭套接字
```


### 3.2.2、创建UDP客户端
```python
import socket    #导入模块

host = "127.0.0.1"   #设置主机地址
port = 8080                  #设置端口

client = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)   #创建套接字
data = input("请输入圆的半径：")
client.sendto(data.encode(),(host,port))   #主动初始化TCP服务器连接
print(client.recv(1024).decode())

client.close()      #关闭套接字
```

![image.png](_img/assets/1661418698851-b49d94b3-4d36-469e-aadc-be9e6c953ed5.png)
